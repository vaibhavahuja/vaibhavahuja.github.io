<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Implementing a chained cache - Vaibhav Ahuja</title>
  <meta name="description" content="my personal space where i write about stuff that excites me.">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">
  <link rel="canonical" href="http://localhost:4000/chained-cache">
  <link rel="alternate" type="application/rss+xml" title="Vaibhav Ahuja" href="http://localhost:4000/feed.xml">
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2WNHZ5BJ2N"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2WNHZ5BJ2N');
</script>
</head>

  <body>
    <div class="page-content">
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Implementing a chained cache</h1>
    <p class="post-meta">
      <time datetime="2024-08-15T16:51:29+05:30" itemprop="datePublished">Aug 15, 2024</time>
      

      
  		

  		
  		

  		&middot;	<span class="tags" itemprop="tags">
  				<a href="http://localhost:4000/tagged#golang">#golang</a>
  			</span>

  	  

    </p>
  </header>
  <div class="post-content" itemprop="articleBody">
    <h3 id="why">Why?</h3>

<p>We recently encountered a use case where we had to fetch data from a source, but as we scaled, we encountered performance issues. Also, the cost of reading from the datasource was extremely high after breaching a certain limit. 
Even if we could compromise on the cost of every request, performance was something highly critical. Naturally, we identified that the data is cacheable, and decided to get a redis layer between the service and datasource. We went ahead with a standalone redis, and fetched data from the redis instance on every call, but there was another problem.</p>

<p>Redis used to reach its memory limits at high throughput, ad We needed another layer of caching, and decided to add an inmemory cache. All the nodes would cache this information in memory, and fetch from redis after a defined interval, which would eventually fetch from the primary data source. (<strong>Chained Cache</strong>). 
<img src="../images/cache_layers.png" alt="" /></p>
<h4 id="why-to-have-redis-in-between-and-not-just-the-primary-source">Why to have Redis in between and not just the primary source.</h4>
<ul>
  <li>To avoid extreme edge cases, where all the inmemory caches expire at t = t1, and all the requests are sent straight to the primary source, thus choking the database. Cost of every search is expensive. We want to avoid calls to the primary data source.</li>
  <li>Wonâ€™t the same thing happen with redis? If all the caches expire, and we get a million requests in one second, redis will go down again.
    <ul>
      <li>We write a locking mechanism, at any time only one go routine will hit the redis and refresh in memory cache, while other go routines wait for some time / return stale data back to the client.</li>
      <li>This means at any point the maximum number of goroutines trying to refresh redis will be equal to the number of pods.</li>
    </ul>
  </li>
</ul>

<h3 id="what">What?</h3>

<p>Chained Cache is a multi-layered caching strategy, each cache having different characteristics, to optimize data retrieval. The idea is to have a hierarchy of caches, where most frequently accessed data is stored in the fastest cache (in memory)</p>

<p>Had to structure this efficiently in my goLang service. My main requirements were:</p>
<ul>
  <li>Add multiple layers of caching</li>
  <li>Invalidation of key on basis of time.</li>
  <li>Refresh L(n) cache from L(n+1) cache in case of invalidation, propagate the change in lower caches.</li>
  <li>Locking while refreshing so only one goroutine accesses the L(n+1) cache.</li>
  <li>Can enable/disable cache/s when I want</li>
  <li>Modify implementation of cache without affecting this chained cache module.</li>
</ul>

<h3 id="solutioning">Solutioning</h3>

<p>Decided to write a quick backtracking solution for the same. In my example, any <code class="language-plaintext highlighter-rouge">struct</code> which implements this interface will be a cache.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">type</span> <span class="n">Cache</span><span class="p">[</span><span class="n">K</span> <span class="n">comparable</span><span class="p">,</span> <span class="n">V</span> <span class="n">any</span><span class="p">]</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">AddKey</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span> <span class="kt">error</span>
    <span class="n">GetVal</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<h3 id="golang-implementation">GoLang Implementation</h3>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="p">(</span><span class="n">chainSecond</span> <span class="o">*</span><span class="n">ChainedCacheSecond</span><span class="p">[</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">])</span> <span class="n">Get</span><span class="p">(</span><span class="n">key</span> <span class="n">K</span><span class="p">,</span> <span class="n">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">currCache</span> <span class="o">:=</span> <span class="n">chainSecond</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">val</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">currCache</span><span class="o">.</span><span class="n">GetVal</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="c">//did not find in currCache so will try to find in parent cache</span>
        <span class="k">if</span> <span class="n">index</span><span class="o">+</span><span class="m">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">chainSecond</span><span class="o">.</span><span class="n">layers</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">chainSecond</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="m">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
                <span class="c">//backtracking and updating the parent caches as well</span>
                <span class="n">currCache</span><span class="o">.</span><span class="n">AddKey</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="c">//successfully found</span>
                <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"found key in cache "</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="m">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="no">nil</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c">//found some error</span>
                <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"key not found"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c">//did not find the value after exploring all caches</span>
        <span class="k">var</span> <span class="n">v</span> <span class="n">V</span>
        <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"did not find the key in any cache"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="n">err</span>
<span class="p">}</span></code></pre></figure>

<h3 id="conclusion">Conclusion</h3>

<p>Using this chained cache, I did achieve what I wanted to. Just a few things to keep in mind :</p>
<ul>
  <li>Be very sure of the base case while writing a recursive solution in production environment. This is very important.</li>
  <li>Depending on the application needs, one must make conscious decisions:
    <ul>
      <li>If one cache fails, serve stale data or throw an error.</li>
      <li>Cases in which one must do negative caching.</li>
    </ul>
  </li>
  <li>Keeping an inmemory cache does provide great latencies, however, one must make sure of choosing the correct eviction policy as per their needs. Not choosing one will choke up the resources real quick.</li>
  <li>Metrics are very important. How else will you know if your solution is working better than the existing one?</li>
</ul>

<p>Hope you learned something!</p>


  </div>
  <hr>
  
    
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname  = 'https-vaibhavahuja-github-io-1';
    var disqus_identifier = '/chained-cache';
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>


  
</article>

      <div class="copyright">
      <p> Powered by <a href="https://jekyllrb.com/">Jekyll</a> </p>
      </div>
    </div>
    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-2WNHZ5BJ2N', 'auto');
  ga('send', 'pageview');
</script>




  </body>
</html>
